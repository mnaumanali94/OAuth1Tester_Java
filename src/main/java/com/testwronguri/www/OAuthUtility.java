/*
 * OAuth1TesterLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ) on 07/11/2016
 */
package com.testwronguri.www;

import java.net.*;
import java.util.*;
import java.io.*;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.security.NoSuchAlgorithmException;
import java.security.InvalidKeyException;
import com.testwronguri.www.http.request.HttpRequest;
import java.util.Base64; //needs Java 8

import org.apache.http.NameValuePair;
import org.apache.http.message.BasicNameValuePair;

public class OAuthUtility {
    static final String OAUTH_CONSUMER_KEY = "oauth_consumer_key";
    static final String OAUTH_NONCE = "oauth_nonce";
    static final String OAUTH_TIMESTAMP = "oauth_timestamp";
    static final String OAUTH_SIGNATURE = "oauth_signature";
    static final String OAUTH_SIGNATURE_METHOD = "oauth_signature_method";
    static final String OAUTH_VERSION = "oauth_version";
    static final String OAUTH_VERSION_NO = "1.0";
    static final String OAUTH_TOKEN = "oauth_token";
    static final String HMAC_SHA1 = "HMAC-SHA1";
    static final String OAUTH_HEADER_FORMAT = "OAuth %1$s";
    static final String OAUTH_HEADER_NAME = "Authorization";
    static final String PORT_FORMAT = ":%1$s";

    /**
    * Appends the necessary OAuth credentials for making this authorized call
    * @param	request	The out going request to access the resource
    */
    public static void appendOAuthParams(HttpRequest request)
            throws SecurityException {
        if (APIHelper.isNullOrWhiteSpace(Configuration.oAuthClientId)) {
            throw new IllegalArgumentException("oAuthClientId");
        }
        else if (APIHelper.isNullOrWhiteSpace(Configuration.oAuthClientSecret)) {
            throw new IllegalArgumentException("oAuthClientSecret");
        }
        else if (APIHelper.isNullOrWhiteSpace(Configuration.oAuthToken)) {
            throw new IllegalArgumentException("oAuthToken");
        }
        else if (APIHelper.isNullOrWhiteSpace(Configuration.oAuthTokenSecret)) {
            throw new IllegalArgumentException("oAuthTokenSecret");
        }
        Random random = new Random();

        Map<String, String> parameters = new HashMap<String, String>();
        parameters.put(OAUTH_CONSUMER_KEY, Configuration.oAuthClientId);            
        parameters.put(OAUTH_NONCE, String.valueOf(random.nextInt()));
        parameters.put(OAUTH_TIMESTAMP, getUnixTimeString());
        parameters.put(OAUTH_VERSION, OAUTH_VERSION_NO);
        parameters.put(OAUTH_SIGNATURE_METHOD, HMAC_SHA1);
        parameters.put(OAUTH_TOKEN, Configuration.oAuthToken);

        try {
            //generate signature for OAuth
            String signature = generateSignature(
                    Configuration.oAuthClientSecret,
                    new URL(request.getQueryUrl()),
                    request.getHttpMethod().toString(),
                    Configuration.oAuthTokenSecret,
                    parameters);
            parameters.put(OAUTH_SIGNATURE, signature);

            String authHeaderVal = joinForHeader(parameters);

            parameters.put(OAUTH_HEADER_NAME, String.format(OAUTH_HEADER_FORMAT, authHeaderVal));
            
            request.getHeaders().putAll(parameters);
        }
        catch(Exception ex) {
            throw new SecurityException(ex);
        }
    }

  
    private static String generateSignature(String consumerSecret, URL uri,
        String method, String tokenSecret, Map<String, String> parameters) {
        try {
            String key = urlEncode(consumerSecret) + "&" + urlEncode(tokenSecret);

            Map<String, String> queryParams = parseQueryString(uri.getQuery());
            queryParams.putAll(parameters);
            String stringParameter = formatQueryString(queryParams);
            String port = "";
            if (!((uri.getProtocol() == "http" && uri.getPort() == 80 )||( uri.getProtocol() == "https" && uri.getPort() == 443)))
                port =  String.format(PORT_FORMAT,uri.getPort());

            String signatureBase = method +
                "&" + urlEncode(uri.getProtocol() + "://" + uri.getHost() + port + uri.getPath()) +
                "&" + urlEncode(stringParameter);

            byte[] hash = computeHash(key, signatureBase);
            return urlEncode(Base64.getEncoder().encodeToString(hash));
        } catch (Exception ex) {
            return null;
        }
    }
    private static byte[] computeHash(String key, String value)
            throws UnsupportedEncodingException, NoSuchAlgorithmException, InvalidKeyException {
        String type = "HmacSHA1";
        SecretKeySpec secret = new SecretKeySpec(key.getBytes("UTF-8"), type);
        Mac mac = Mac.getInstance(type);
        mac.init(secret);
        return mac.doFinal(value.getBytes("UTF-8"));
    }

    private static String getUnixTimeString() {
        long timestamp = System.currentTimeMillis();
        return String.valueOf(timestamp / 1000);
    }

    private static String urlEncode(String stringToEscape) {
        try {
            String encoded = URLEncoder.encode(stringToEscape, "UTF-8");
            return encoded;
        } catch (Exception ex) {
            return null;
        }
    }

    private static String urlDecode(String stringToUnescape) {
        try {
            stringToUnescape = stringToUnescape.replace('+', ' ');
            return URLDecoder.decode(stringToUnescape, "UTF-8");
        } catch (Exception ex) {
            return null;
        }
    }
        
    private static String formatQueryString(Map<String, String> parameters) {
        ArrayList<NameValuePair> paramToSort = new ArrayList<NameValuePair>();
        for(Map.Entry<String, String> entry : parameters.entrySet()){
            if(entry.getKey() == "realm") {
                continue;
            }
            paramToSort.add(new BasicNameValuePair(entry.getKey(), entry.getValue()));
        }

        //sort by name and then by value
        Collections.sort(paramToSort, new Comparator<NameValuePair>() {
            public int compare(NameValuePair a, NameValuePair b) {
                int val = a.getName().compareTo((b.getName()));
                if(val != 0)
                    return val;

                return a.getValue().compareTo(b.getValue());
            }
        });

        //create query string out of array list
        return joinForQuery(paramToSort);
    }

    private static Map<String, String> parseQueryString(String query)
            throws UnsupportedEncodingException {
        Map<String, String> queryParams = new HashMap<String, String>();

        //query is optional for an API call, so it may be null
        if(APIHelper.isNullOrWhiteSpace(query))
            return queryParams;

        String[] sparams = query.trim().split("&");

        for(String qparam : sparams) {
            String[] tokens = qparam.split("=");
            if(tokens.length != 2)
                continue;

            queryParams.put(urlDecode(tokens[0]), urlDecode(tokens[1]));
        }
        return queryParams;
    }

    private static String joinForHeader(Map<String, String> toJoin) {
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for(Map.Entry<String, String> entry : toJoin.entrySet()){
            if (!first) {
                sb.append(',');
            } else {
                first = false;
            }
            sb.append(String.format("%1$s=\"%2$s\"", entry.getKey(), entry.getValue()));
        }
        return sb.toString();
    }
    
    private static String joinForQuery(ArrayList<NameValuePair> toJoin) {
        //create query string out of array list
        StringBuilder sb = new StringBuilder();
        boolean first = true;
        for(NameValuePair pair : toJoin) {
            if (!first) {
                sb.append('&');
            } else {
                first = false;
            }
            sb.append(String.format("%1$s=%2$s", pair.getName(), urlEncode(pair.getValue())));
        }
        return sb.toString();
    }
}